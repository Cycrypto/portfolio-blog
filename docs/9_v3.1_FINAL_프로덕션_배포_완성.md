# Tiptap ë¦¬íŒ©í† ë§ v3.1 FINAL - í”„ë¡œë•ì…˜ ë°°í¬ ì™„ì„±ë³¸

## ğŸ“‹ ë¬¸ì„œ ì •ë³´

- **ì‘ì„±ì¼**: 2025-12-30
- **ë²„ì „**: 3.1 FINAL (ì‹¤ì „ ê²€ì¦ ì™„ë£Œ)
- **ì´ì „ ë²„ì „**: 3.1 REVISED â†’ í”„ë¡œë•ì…˜ ì¥ì•  ìš”ì¸ ì œê±°
- **ê²€ì¦ ìƒíƒœ**: ì‹¤ì œ ë™ì‘ + ì—£ì§€ ì¼€ì´ìŠ¤ ë³´ì™„

---

## ğŸ¯ FINAL ì£¼ìš” ìˆ˜ì • ì‚¬í•­ (REVISED ëŒ€ë¹„)

| í•­ëª© | REVISED ë¬¸ì œì  | FINAL í•´ê²° |
|------|---------------|-----------|
| **A. TOC** | slugify ë¹ˆ ê°’, ê¸°ì¡´ id ë¬´ì‹œ | âœ… fallback + ê¸°ì¡´ id ë³´ì¡´ |
| **DOMPurify** | Hook ì ìš© ë°©ì‹ ì˜¤ë¥˜ | âœ… addHook ì •í™•í•œ êµ¬í˜„ |
| **B. Auth** | Origin Guard SSR ê¹¨ì§ | âœ… CSRF Double Submit |
| **D. CSP** | ì„œë“œíŒŒí‹° ìŠ¤í¬ë¦½íŠ¸ ë¯¸ëª…ì‹œ | âœ… ë„ë©”ì¸ ëª…í™•í™” |
| **E. Search** | ì»¬ëŸ¼ëª…/í”Œëœ ë¯¸ê²€ì¦ | âœ… ì¿¼ë¦¬ í”Œëœ ì²´í¬ë¦¬ìŠ¤íŠ¸ |

---

## ğŸ”§ Issue A: TOC ì•µì»¤ ID (FINAL - ì—£ì§€ ì¼€ì´ìŠ¤ ë³´ì™„)

### 1. Heading ID ìƒì„± + ì™„ì „í•œ Dedupe

```typescript
// backend/src/posts/utils/heading-processor.ts
import { JSDOM } from 'jsdom';
import crypto from 'crypto';

/**
 * í…ìŠ¤íŠ¸ë¥¼ URL-safe slugë¡œ ë³€í™˜
 */
export function slugify(text: string): string {
  const slug = text
    .toLowerCase()
    .trim()
    // í•œê¸€, ì˜ë¬¸, ìˆ«ì, ê³µë°±, í•˜ì´í”ˆë§Œ ë‚¨ê¹€
    .replace(/[^a-z0-9ê°€-í£\s-]/g, '')
    // ê³µë°± â†’ í•˜ì´í”ˆ
    .replace(/\s+/g, '-')
    // ì—°ì† í•˜ì´í”ˆ ì œê±°
    .replace(/-+/g, '-')
    // ì•ë’¤ í•˜ì´í”ˆ ì œê±°
    .replace(/^-|-$/g, '');

  // âœ… FINAL: ë¹ˆ slug fallback
  if (!slug) {
    return 'section';  // ê¸°ë³¸ê°’
  }

  return slug;
}

/**
 * HTMLì— Heading ID ì£¼ì… + ì¤‘ë³µ ì œëª© dedupe
 */
export function injectHeadingIds(html: string): {
  html: string;
  headings: Array<{ level: number; text: string; id: string }>;
} {
  const dom = new JSDOM(html);
  const document = dom.window.document;
  const headingElements = document.querySelectorAll('h1, h2, h3, h4, h5, h6');

  const headings: Array<{ level: number; text: string; id: string }> = [];
  const usedIds = new Set<string>();  // âœ… ì‚¬ìš©ëœ ID ì¶”ì 

  headingElements.forEach((element, index) => {
    const level = parseInt(element.tagName[1]);
    const text = element.textContent?.trim() || '';

    if (!text) {
      return;  // ë¹ˆ ì œëª©ì€ ê±´ë„ˆëœ€
    }

    // âœ… FINAL: ê¸°ì¡´ ID ë³´ì¡´ ì •ì±…
    const existingId = element.getAttribute('id');
    let finalId: string;

    if (existingId && existingId.trim() && !usedIds.has(existingId)) {
      // ê¸°ì¡´ IDê°€ ìœ íš¨í•˜ê³  ì¤‘ë³µë˜ì§€ ì•Šìœ¼ë©´ ë³´ì¡´
      finalId = existingId.trim();
    } else {
      // ìƒˆë¡œ ìƒì„±
      let baseId = slugify(text);

      // âœ… ì¤‘ë³µ ì œëª© ì²˜ë¦¬ (dedupe)
      if (usedIds.has(baseId)) {
        let counter = 2;
        while (usedIds.has(`${baseId}-${counter}`)) {
          counter++;
        }
        finalId = `${baseId}-${counter}`;
      } else {
        finalId = baseId;
      }
    }

    // ID ì¶”ì  ë° ì ìš©
    usedIds.add(finalId);
    element.setAttribute('id', finalId);

    // TOC ë°ì´í„° ìˆ˜ì§‘
    headings.push({ level, text, id: finalId });
  });

  return {
    html: document.body.innerHTML,
    headings,
  };
}
```

### 2. DOMPurify ì„¤ì • (ì •í™•í•œ Hook êµ¬í˜„)

```typescript
// backend/src/posts/utils/content-renderer.ts
import { generateHTML, generateText, JSONContent } from '@tiptap/core';
import StarterKit from '@tiptap/starter-kit';
import Image from '@tiptap/extension-image';
import Link from '@tiptap/extension-link';
import Table from '@tiptap/extension-table';
import TableRow from '@tiptap/extension-table-row';
import TableCell from '@tiptap/extension-table-cell';
import TableHeader from '@tiptap/extension-table-header';
import { JSDOM } from 'jsdom';
import DOMPurify from 'isomorphic-dompurify';
import { marked } from 'marked';
import { injectHeadingIds } from './heading-processor';

// âœ… ì‹±ê¸€í„´: ëª¨ë“ˆ ë¡œë“œ ì‹œ 1íšŒë§Œ ìƒì„±
const window = new JSDOM('').window;
const purify = DOMPurify(window);

// âœ… FINAL: Hookì€ addHookìœ¼ë¡œ ë“±ë¡
purify.addHook('uponSanitizeAttribute', (node, data) => {
  const attrName = data.attrName;
  const attrValue = String(data.attrValue || '');

  // âœ… <img src="data:image/..."> í—ˆìš©
  if (node.tagName === 'IMG' && attrName === 'src') {
    if (attrValue.startsWith('data:image/')) {
      return;  // í—ˆìš©
    }
  }

  // âœ… <a href="javascript:..."> ì°¨ë‹¨
  // âœ… <a href="data:..."> ì°¨ë‹¨
  if (attrName === 'href') {
    if (attrValue.startsWith('javascript:') || attrValue.startsWith('data:')) {
      data.keepAttr = false;
    }
  }

  // âœ… <img src="javascript:..."> ì°¨ë‹¨
  if (attrName === 'src') {
    if (attrValue.startsWith('javascript:')) {
      data.keepAttr = false;
    }
  }
});

// Viewerìš© ê²½ëŸ‰ Extensions
const viewerExtensions = [
  StarterKit.configure({
    history: false,
  }),
  Image.configure({
    HTMLAttributes: {
      class: 'rounded-lg max-w-full h-auto my-4',
      loading: 'lazy',
    },
  }),
  Link.configure({
    openOnClick: false,
    HTMLAttributes: {
      class: 'text-blue-600 underline hover:text-blue-800',
      rel: 'noopener noreferrer',
      target: '_blank',
    },
  }),
  Table,
  TableRow,
  TableCell,
  TableHeader,
];

// âœ… DOMPurify ê¸°ë³¸ ì„¤ì •
const PURIFY_CONFIG = {
  ALLOWED_TAGS: [
    'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
    'p', 'br', 'strong', 'em', 'u', 's',
    'a', 'img',
    'ul', 'ol', 'li',
    'blockquote', 'code', 'pre',
    'table', 'thead', 'tbody', 'tr', 'th', 'td',
    'div', 'span',
  ],
  ALLOWED_ATTR: [
    'href', 'src', 'alt', 'title', 'class',
    'target', 'rel', 'loading', 'id',
  ],
  ALLOW_DATA_ATTR: false,

  // âœ… FINAL: ê¸°ë³¸ í”„ë¡œí† ì½œ ì œí•œ (Hookì—ì„œ ì„¸ë°€ ì œì–´)
  ALLOWED_URI_REGEXP: /^(?:(?:https?|mailto|data:image\/):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i,
};

/**
 * Tiptap JSONì„ ì•ˆì „í•œ HTMLë¡œ ë³€í™˜
 */
export function renderTiptapToHTML(json: JSONContent): {
  html: string;
  headings: Array<{ level: number; text: string; id: string }>;
} {
  try {
    // 1. Tiptap â†’ HTML
    const rawHtml = generateHTML(json, viewerExtensions);

    // 2. âœ… Heading ID ì£¼ì… + dedupe
    const { html: htmlWithIds, headings } = injectHeadingIds(rawHtml);

    // 3. DOMPurify Sanitize
    const sanitizedHtml = purify.sanitize(htmlWithIds, PURIFY_CONFIG);

    // âœ… FINAL: sanitize í›„ headings ì •í•©ì„± ê²€ì¦ (ì„ íƒì )
    // í”„ë¡œë•ì…˜ì—ì„œëŠ” DOMPurify ì„¤ì •ì´ idë¥¼ ì œê±°í•˜ì§€ ì•Šë„ë¡ í…ŒìŠ¤íŠ¸ ê³ ì •
    // ì—¬ê¸°ì„œëŠ” ê²½ê³ ë§Œ ë¡œê¹…
    if (process.env.NODE_ENV === 'development') {
      const sanitizedDom = new JSDOM(sanitizedHtml);
      const sanitizedHeadings = sanitizedDom.window.document.querySelectorAll('h1, h2, h3, h4, h5, h6');

      if (sanitizedHeadings.length !== headings.length) {
        console.warn(
          `âš ï¸ Heading count mismatch after sanitize: ${headings.length} â†’ ${sanitizedHeadings.length}`
        );
      }
    }

    return {
      html: sanitizedHtml,
      headings,
    };
  } catch (error) {
    console.error('Tiptap rendering failed:', error);
    return {
      html: '<p class="text-red-500">ì½˜í…ì¸ ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>',
      headings: [],
    };
  }
}

/**
 * Markdownì„ ì•ˆì „í•œ HTMLë¡œ ë³€í™˜
 */
export function renderMarkdownToHTML(markdown: string): {
  html: string;
  headings: Array<{ level: number; text: string; id: string }>;
} {
  try {
    // 1. Markdown â†’ HTML
    const rawHtml = marked.parse(markdown, {
      breaks: true,
      gfm: true,
    }) as string;

    // 2. âœ… Heading ID ì£¼ì… + dedupe
    const { html: htmlWithIds, headings } = injectHeadingIds(rawHtml);

    // 3. DOMPurify Sanitize
    const sanitizedHtml = purify.sanitize(htmlWithIds, PURIFY_CONFIG);

    return {
      html: sanitizedHtml,
      headings,
    };
  } catch (error) {
    console.error('Markdown rendering failed:', error);
    return {
      html: '<p class="text-red-500">ì½˜í…ì¸ ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>',
      headings: [],
    };
  }
}

// ... ë‚˜ë¨¸ì§€ í•¨ìˆ˜ëŠ” ë™ì¼
export function extractPlainTextFromTiptap(json: JSONContent): string {
  try {
    return generateText(json, viewerExtensions);
  } catch (error) {
    console.error('Plain text extraction failed:', error);
    return '';
  }
}

export function extractPlainTextFromMarkdown(markdown: string): string {
  try {
    const html = marked.parse(markdown, { breaks: true, gfm: true }) as string;
    return html.replace(/<[^>]*>/g, '').trim();
  } catch (error) {
    console.error('Plain text extraction failed:', error);
    return '';
  }
}

export function calculateWordCount(plainText: string): number {
  return plainText.split(/\s+/).filter((word) => word.length > 0).length;
}

export function calculateReadingTime(wordCount: number): number {
  const wordsPerMinute = 200;
  return Math.ceil(wordCount / wordsPerMinute);
}
```

### 3. í…ŒìŠ¤íŠ¸: ì—£ì§€ ì¼€ì´ìŠ¤

```typescript
// backend/test/utils/heading-processor.spec.ts
import { injectHeadingIds, slugify } from '../src/posts/utils/heading-processor';

describe('Heading ID Injection (FINAL)', () => {
  it('should handle empty slug with fallback', () => {
    const html = '<h2>ğŸ‰</h2>';  // ì´ëª¨ì§€ë§Œ
    const { html: result, headings } = injectHeadingIds(html);

    expect(result).toContain('<h2 id="section">ğŸ‰</h2>');
    expect(headings[0].id).toBe('section');
  });

  it('should preserve existing valid IDs', () => {
    const html = `
      <h2 id="custom-intro">ì†Œê°œ</h2>
      <h2>ì†Œê°œ</h2>
    `;
    const { html: result, headings } = injectHeadingIds(html);

    // âœ… ê¸°ì¡´ ID ë³´ì¡´
    expect(result).toContain('<h2 id="custom-intro">ì†Œê°œ</h2>');

    // âœ… ë‘ ë²ˆì§¸ëŠ” ìƒˆë¡œìš´ ID
    expect(result).toContain('<h2 id="ì†Œê°œ">ì†Œê°œ</h2>');

    expect(headings).toEqual([
      { level: 2, text: 'ì†Œê°œ', id: 'custom-intro' },
      { level: 2, text: 'ì†Œê°œ', id: 'ì†Œê°œ' },
    ]);
  });

  it('should handle duplicate headings', () => {
    const html = `
      <h2>ì†Œê°œ</h2>
      <h2>ì†Œê°œ</h2>
      <h2>ì†Œê°œ</h2>
    `;
    const { html: result, headings } = injectHeadingIds(html);

    expect(result).toContain('<h2 id="ì†Œê°œ">ì†Œê°œ</h2>');
    expect(result).toContain('<h2 id="ì†Œê°œ-2">ì†Œê°œ</h2>');
    expect(result).toContain('<h2 id="ì†Œê°œ-3">ì†Œê°œ</h2>');
  });

  it('should sanitize special characters', () => {
    const text = 'React.js: ì‹œì‘í•˜ê¸° (2025)!@#';
    const slug = slugify(text);

    expect(slug).toBe('reactjs-ì‹œì‘í•˜ê¸°-2025');
  });
});
```

---

## ğŸ”§ Issue B: Cookie Auth (FINAL - SSR í˜¸í™˜ CSRF)

### âš ï¸ Origin Guard ì œê±° ì´ìœ 

**ë¬¸ì œì **:
1. Next.js Server Componentì˜ `fetch()`ëŠ” **Origin í—¤ë”ê°€ ì—†ìŒ**
2. ì„œë²„ ë‚´ë¶€ í˜¸ì¶œ, Cron, Health Check ëª¨ë‘ ì°¨ë‹¨ë¨
3. `Referer`ë„ ì—†ëŠ” ê²½ìš°ê°€ ë§ìŒ (HTTPS â†’ HTTP ì „í™˜ ë“±)

**í•´ê²°**: CSRF Double Submit Cookie ë°©ì‹ìœ¼ë¡œ ì „í™˜

---

### 1. CSRF í† í° ìƒì„± ë° ê²€ì¦

```typescript
// backend/src/auth/auth.controller.ts
import { Controller, Post, Get, Body, Res, Req, HttpCode } from '@nestjs/common';
import { Response, Request } from 'express';
import { AuthService } from './auth.service';
import { randomBytes } from 'crypto';

@Controller('auth')
export class AuthController {
  constructor(private authService: AuthService) {}

  @Post('login')
  @HttpCode(200)
  async login(
    @Body() loginDto: { email: string; password: string },
    @Res({ passthrough: true }) response: Response
  ) {
    const { access_token, user } = await this.authService.login(loginDto);

    // âœ… í™˜ê²½ë³„ Domain ì„¤ì •
    const cookieDomain = process.env.NODE_ENV === 'production'
      ? process.env.COOKIE_DOMAIN  // '.example.com'
      : undefined;  // localhost

    // âœ… Auth Token (HttpOnly)
    response.cookie('auth-token', access_token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      domain: cookieDomain,
      maxAge: 7 * 24 * 60 * 60 * 1000,  // 7ì¼
      path: '/',
    });

    // âœ… CSRF Token (JS ì½ê¸° ê°€ëŠ¥)
    const csrfToken = randomBytes(32).toString('hex');
    response.cookie('csrf-token', csrfToken, {
      httpOnly: false,  // âœ… JSì—ì„œ ì½ì–´ì•¼ í•¨
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      domain: cookieDomain,
      maxAge: 7 * 24 * 60 * 60 * 1000,
      path: '/',
    });

    return {
      message: 'Login successful',
      user: { id: user.id, email: user.email, role: user.role },
      csrfToken,  // âœ… í´ë¼ì´ì–¸íŠ¸ê°€ í—¤ë”ì— ì‚¬ìš©
    };
  }

  @Post('logout')
  @HttpCode(200)
  async logout(@Res({ passthrough: true }) response: Response) {
    response.clearCookie('auth-token');
    response.clearCookie('csrf-token');

    return { message: 'Logout successful' };
  }

  @Get('me')
  async getMe(@Req() request: Request) {
    // JWT ê²€ì¦ (JwtGuard ì‚¬ìš©)
    return request.user;
  }
}
```

### 2. CSRF Guard (Double Submit)

```typescript
// backend/src/common/guards/csrf.guard.ts
import { Injectable, CanActivate, ExecutionContext, ForbiddenException } from '@nestjs/common';
import { Request } from 'express';

@Injectable()
export class CsrfGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest<Request>();

    // âœ… GET/HEAD/OPTIONSëŠ” CSRF ê²€ì¦ ì œì™¸ (ì½ê¸° ì „ìš©)
    if (['GET', 'HEAD', 'OPTIONS'].includes(request.method)) {
      return true;
    }

    // âœ… ì„œë²„ ë‚´ë¶€ ìš”ì²­ ì‹ë³„ (ì„ íƒì )
    const internalHeader = request.headers['x-internal-request'];
    if (internalHeader === process.env.INTERNAL_REQUEST_SECRET) {
      return true;  // ì„œë²„ ê°„ í˜¸ì¶œ í—ˆìš©
    }

    // âœ… Double Submit Cookie ê²€ì¦
    const csrfTokenFromCookie = request.cookies['csrf-token'];
    const csrfTokenFromHeader = request.headers['x-csrf-token'] as string;

    if (!csrfTokenFromCookie || !csrfTokenFromHeader) {
      throw new ForbiddenException('CSRF token missing');
    }

    if (csrfTokenFromCookie !== csrfTokenFromHeader) {
      throw new ForbiddenException('CSRF token mismatch');
    }

    return true;
  }
}
```

### 3. Controller ì ìš©

```typescript
// backend/src/posts/controller/posts.controller.ts
import { CsrfGuard } from '../../common/guards/csrf.guard';

@HttpPost()
@UseGuards(JwtRoleGuard, CsrfGuard)  // âœ… CSRF ê²€ì¦
@Roles('admin')
async createPost(@Body() createPostDTO: CreatePostRequestDTO) {
  // ...
}

@Patch(':id')
@UseGuards(JwtRoleGuard, CsrfGuard)  // âœ… CSRF ê²€ì¦
@Roles('admin')
async updatePost(
  @Param('id') id: string,
  @Body() updatePostDTO: UpdatePostRequestDTO
) {
  // ...
}
```

### 4. CORS ì„¤ì • (CSRF í—¤ë” í—ˆìš©)

```typescript
// backend/src/main.ts
app.enableCors({
  origin: process.env.FRONTEND_URL,
  credentials: true,
  methods: ['GET', 'POST', 'PATCH', 'DELETE', 'OPTIONS'],
  allowedHeaders: [
    'Content-Type',
    'Authorization',
    'X-CSRF-Token',  // âœ… FINAL: CSRF í—¤ë” í—ˆìš©
  ],
});
```

### 5. í”„ë¡ íŠ¸ì—”ë“œ: CSRF í† í° ìë™ ì „ì†¡

```typescript
// frontend/lib/api.ts
const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3002';

/**
 * CSRF í† í° ê°€ì ¸ì˜¤ê¸° (ì¿ í‚¤ì—ì„œ)
 */
function getCsrfToken(): string | null {
  if (typeof document === 'undefined') return null;

  const cookies = document.cookie.split(';');
  const csrfCookie = cookies.find(c => c.trim().startsWith('csrf-token='));

  if (!csrfCookie) return null;

  return csrfCookie.split('=')[1];
}

/**
 * POST ìš”ì²­ (CSRF í† í° ìë™ ì¶”ê°€)
 */
export async function createPost(data: any) {
  const csrfToken = getCsrfToken();

  const response = await fetch(`${API_URL}/posts`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRF-Token': csrfToken || '',  // âœ… CSRF í—¤ë”
    },
    credentials: 'include',  // âœ… ì¿ í‚¤ ì „ì†¡
    body: JSON.stringify(data),
  });

  if (!response.ok) {
    throw new Error('Failed to create post');
  }

  return response.json();
}

/**
 * PATCH ìš”ì²­
 */
export async function updatePost(id: string, data: any) {
  const csrfToken = getCsrfToken();

  const response = await fetch(`${API_URL}/posts/${id}`, {
    method: 'PATCH',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRF-Token': csrfToken || '',
    },
    credentials: 'include',
    body: JSON.stringify(data),
  });

  if (!response.ok) {
    throw new Error('Failed to update post');
  }

  return response.json();
}

/**
 * DELETE ìš”ì²­
 */
export async function deletePost(id: string) {
  const csrfToken = getCsrfToken();

  const response = await fetch(`${API_URL}/posts/${id}`, {
    method: 'DELETE',
    headers: {
      'X-CSRF-Token': csrfToken || '',
    },
    credentials: 'include',
  });

  if (!response.ok) {
    throw new Error('Failed to delete post');
  }

  return response.json();
}
```

### 6. SSR í˜¸í™˜ (ì„œë²„ ë‚´ë¶€ í˜¸ì¶œ)

```typescript
// frontend/app/admin/layout.tsx (Server Component)
import { redirect } from 'next/navigation'
import { cookies } from 'next/headers'

export default async function AdminLayout({ children }: { children: React.ReactNode }) {
  const cookieStore = await cookies()
  const token = cookieStore.get('auth-token')?.value

  if (!token) {
    redirect('/login')
  }

  // âœ… ì„œë²„ ë‚´ë¶€ í˜¸ì¶œ (CSRF ê²€ì¦ ì œì™¸)
  try {
    const response = await fetch(`${process.env.API_URL}/auth/me`, {
      headers: {
        Cookie: `auth-token=${token}`,
        'X-Internal-Request': process.env.INTERNAL_REQUEST_SECRET || '',  // âœ… ì„œë²„ ì¸ì¦
      },
      cache: 'no-store',
    })

    if (!response.ok) {
      redirect('/login')
    }
  } catch (error) {
    redirect('/login')
  }

  return <>{children}</>
}
```

**í™˜ê²½ë³€ìˆ˜**:
```env
# backend/.env
INTERNAL_REQUEST_SECRET=your-secret-key-here

# frontend/.env.local
INTERNAL_REQUEST_SECRET=your-secret-key-here
```

---

## ğŸ”§ Issue C/D: CSP (FINAL - ì„œë“œíŒŒí‹° ëª…ì‹œ)

### CSP ì •ì±… ëª…í™•í™”

```typescript
// frontend/middleware.ts
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

/**
 * Edge Runtime í˜¸í™˜ nonce ìƒì„±
 */
function generateNonce(): string {
  const array = new Uint8Array(16);
  crypto.getRandomValues(array);

  const base64 = btoa(String.fromCharCode(...array));
  return base64
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=/g, '');
}

export function middleware(request: NextRequest) {
  const nonce = generateNonce();
  const response = NextResponse.next();

  // âœ… FINAL: ì„œë“œíŒŒí‹° ìŠ¤í¬ë¦½íŠ¸ ë„ë©”ì¸ ëª…ì‹œ
  const scriptSources = [
    "'self'",
    `'nonce-${nonce}'`,
    // âœ… í•„ìš”í•œ ì„œë“œíŒŒí‹° CDN ì¶”ê°€ (ì—†ìœ¼ë©´ ì œê±°)
    // 'https://cdn.jsdelivr.net',
    // 'https://www.googletagmanager.com',
  ].join(' ');

  const cspHeader = `
    default-src 'self';
    script-src ${scriptSources};
    style-src 'self' 'unsafe-inline';
    img-src 'self' data: https:;
    font-src 'self' data:;
    connect-src 'self' ${process.env.NEXT_PUBLIC_API_URL || ''};
    frame-ancestors 'none';
    base-uri 'self';
    form-action 'self';
  `.replace(/\s{2,}/g, ' ').trim();

  response.headers.set('Content-Security-Policy', cspHeader);
  response.headers.set('X-Frame-Options', 'DENY');
  response.headers.set('X-Content-Type-Options', 'nosniff');
  response.headers.set('X-Nonce', nonce);

  return response;
}

export const config = {
  matcher: '/:path*',
}
```

### Inline Scriptì— Nonce ì ìš© (í•„ìš” ì‹œë§Œ)

```typescript
// frontend/app/layout.tsx
import { headers } from 'next/headers'

export default async function RootLayout({ children }: { children: React.ReactNode }) {
  const headersList = await headers()
  const nonce = headersList.get('X-Nonce') || ''

  return (
    <html lang="ko">
      <head>
        {/* âœ… Inline scriptì—ë§Œ nonce í•„ìš” */}
        {nonce && (
          <script
            nonce={nonce}
            dangerouslySetInnerHTML={{
              __html: `
                (function() {
                  // Google Analytics ë“±
                  console.log('App initialized');
                })();
              `,
            }}
          />
        )}
      </head>
      <body>{children}</body>
    </html>
  )
}
```

---

## ğŸ”§ Issue E: í•œêµ­ì–´ ê²€ìƒ‰ (FINAL - ì¿¼ë¦¬ í”Œëœ ê²€ì¦)

### 1. Migration (Fallback í¬í•¨)

```typescript
// backend/migrations/YYYYMMDDHHMMSS-add-tiptap-fields.ts
import { MigrationInterface, QueryRunner, TableColumn } from 'typeorm';

export class AddTiptapFields1234567890123 implements MigrationInterface {
  public async up(queryRunner: QueryRunner): Promise<void> {
    // ... ì»¬ëŸ¼ ì¶”ê°€ ì½”ë“œ

    // âœ… pg_trgm Extension + ì¸ë±ìŠ¤
    try {
      await queryRunner.query(`CREATE EXTENSION IF NOT EXISTS pg_trgm;`);

      await queryRunner.query(`
        CREATE INDEX idx_posts_plain_text_trgm
        ON posts USING gin(plain_text gin_trgm_ops);
      `);

      console.log('âœ… pg_trgm index created');
    } catch (error) {
      console.warn('âš ï¸ pg_trgm not available, using simple index');

      // âœ… Fallback: simple ì¸ë±ìŠ¤
      await queryRunner.query(`
        CREATE INDEX idx_posts_plain_text_simple
        ON posts USING gin(to_tsvector('simple', plain_text));
      `);
    }

    // contentType ì¸ë±ìŠ¤
    await queryRunner.query(`
      CREATE INDEX idx_posts_content_type ON posts(content_type)
    `);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query('DROP INDEX IF EXISTS idx_posts_plain_text_trgm');
    await queryRunner.query('DROP INDEX IF EXISTS idx_posts_plain_text_simple');
    await queryRunner.query('DROP INDEX IF EXISTS idx_posts_content_type');
  }
}
```

### 2. ê²€ìƒ‰ ì¿¼ë¦¬ (ì •í™•í•œ ì»¬ëŸ¼ëª…)

```typescript
// backend/src/posts/service/posts.service.ts
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Post } from '../entity/post.entity';

@Injectable()
export class PostsService {
  constructor(
    @InjectRepository(Post)
    private readonly postRepository: Repository<Post>,
  ) {}

  /**
   * pg_trgm ì‚¬ìš© ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸
   */
  private async hasPgTrgm(): Promise<boolean> {
    try {
      const result = await this.postRepository.query(
        `SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm'`
      );
      return result.length > 0;
    } catch (error) {
      return false;
    }
  }

  /**
   * í•œêµ­ì–´ ê²€ìƒ‰ (pg_trgm ìš°ì„ , fallback ILIKE)
   */
  async getPosts(
    keyword: string = '',
    tag: string = '',
    page: number = 1,
    pageSize: number = 10
  ): Promise<Post[]> {
    const queryBuilder = this.postRepository
      .createQueryBuilder('post')
      .leftJoinAndSelect('post.tags', 'tag')
      .where('post.status = :status', { status: 'published' });

    // âœ… ê²€ìƒ‰ ë¡œì§
    if (keyword && keyword.trim().length >= 2) {
      const cleanKeyword = keyword.trim();
      const usePgTrgm = await this.hasPgTrgm();

      if (usePgTrgm) {
        // âœ… pg_trgm ê²€ìƒ‰ (% ì—°ì‚°ì)
        queryBuilder.andWhere(
          // âœ… FINAL: ì •í™•í•œ ì»¬ëŸ¼ëª… í™•ì¸ (plain_text ë˜ëŠ” plainText)
          '(post.plainText % :keyword OR post.title % :keyword)',
          { keyword: cleanKeyword }  // âœ… raw í‚¤ì›Œë“œ (% ì œê±°)
        );

        // âœ… ìœ ì‚¬ë„ ê¸°ë°˜ ì •ë ¬
        queryBuilder.addSelect(
          `(similarity(post.title, :keyword) * 2 + similarity(post.plainText, :keyword))`,
          'relevance'
        );
        queryBuilder.setParameter('keyword', cleanKeyword);
        queryBuilder.orderBy('relevance', 'DESC');
      } else {
        // âœ… Fallback: ILIKE
        queryBuilder.andWhere(
          '(post.title ILIKE :keywordPattern OR post.plainText ILIKE :keywordPattern)',
          { keywordPattern: `%${cleanKeyword}%` }
        );
        queryBuilder.orderBy('post.publishDate', 'DESC');
      }
    } else if (!keyword) {
      // í‚¤ì›Œë“œ ì—†ìœ¼ë©´ ìµœì‹ ìˆœ
      queryBuilder.orderBy('post.publishDate', 'DESC');
    }

    // íƒœê·¸ í•„í„°
    if (tag) {
      queryBuilder.andWhere('tag.name = :tag', { tag });
    }

    // í˜ì´ì§€ë„¤ì´ì…˜
    queryBuilder
      .skip((page - 1) * pageSize)
      .take(pageSize);

    return queryBuilder.getMany();
  }

  /**
   * ê²€ìƒ‰ ê²°ê³¼ ì¹´ìš´íŠ¸
   */
  async getPostsCount(keyword: string = '', tag: string = ''): Promise<number> {
    const queryBuilder = this.postRepository
      .createQueryBuilder('post')
      .where('post.status = :status', { status: 'published' });

    if (keyword && keyword.trim().length >= 2) {
      const cleanKeyword = keyword.trim();
      const usePgTrgm = await this.hasPgTrgm();

      if (usePgTrgm) {
        queryBuilder.andWhere(
          '(post.plainText % :keyword OR post.title % :keyword)',
          { keyword: cleanKeyword }
        );
      } else {
        queryBuilder.andWhere(
          '(post.title ILIKE :keywordPattern OR post.plainText ILIKE :keywordPattern)',
          { keywordPattern: `%${cleanKeyword}%` }
        );
      }
    }

    if (tag) {
      queryBuilder
        .leftJoin('post.tags', 'tag')
        .andWhere('tag.name = :tag', { tag });
    }

    return queryBuilder.getCount();
  }
}
```

### 3. ì¿¼ë¦¬ í”Œëœ ê²€ì¦ ìŠ¤í¬ë¦½íŠ¸

```typescript
// backend/scripts/verify-search-index.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from '../src/app.module';
import { DataSource } from 'typeorm';

async function verifySearchIndex() {
  const app = await NestFactory.createApplicationContext(AppModule);
  const dataSource = app.get(DataSource);

  console.log('ğŸ” Verifying search index...\n');

  // âœ… Extension í™•ì¸
  const extensionCheck = await dataSource.query(
    `SELECT extname, extversion FROM pg_extension WHERE extname = 'pg_trgm'`
  );

  if (extensionCheck.length > 0) {
    console.log('âœ… pg_trgm extension:', extensionCheck[0].extversion);
  } else {
    console.warn('âš ï¸ pg_trgm extension NOT installed');
  }

  // âœ… ì¸ë±ìŠ¤ í™•ì¸
  const indexes = await dataSource.query(`
    SELECT indexname, indexdef
    FROM pg_indexes
    WHERE tablename = 'posts'
      AND indexname LIKE '%plain_text%'
  `);

  console.log('\nğŸ“Š Plain text indexes:');
  indexes.forEach((idx: any) => {
    console.log(`  - ${idx.indexname}`);
    console.log(`    ${idx.indexdef}`);
  });

  // âœ… ì¿¼ë¦¬ í”Œëœ í™•ì¸
  const testKeyword = 'ë¦¬ì•¡íŠ¸';

  console.log(`\nğŸ” Testing query plan for keyword: "${testKeyword}"\n`);

  const plan = await dataSource.query(`
    EXPLAIN (ANALYZE, BUFFERS, FORMAT JSON)
    SELECT * FROM posts
    WHERE plain_text % $1
    ORDER BY similarity(plain_text, $1) DESC
    LIMIT 10
  `, [testKeyword]);

  const planData = plan[0]['QUERY PLAN'][0];

  console.log('ğŸ“ˆ Execution Time:', planData['Execution Time'], 'ms');
  console.log('ğŸ“Š Planning Time:', planData['Planning Time'], 'ms');

  // âœ… ì¸ë±ìŠ¤ ì‚¬ìš© ì—¬ë¶€ í™•ì¸
  const usesIndex = JSON.stringify(planData).includes('Index Scan') ||
                     JSON.stringify(planData).includes('Bitmap Index Scan');

  if (usesIndex) {
    console.log('âœ… Index is being used');
  } else {
    console.warn('âš ï¸ Index NOT being used (Sequential Scan detected)');
  }

  console.log('\nğŸ“ Full plan:');
  console.log(JSON.stringify(planData, null, 2));

  await app.close();
}

verifySearchIndex()
  .then(() => {
    console.log('\nâœ¨ Verification complete');
    process.exit(0);
  })
  .catch((error) => {
    console.error('\nğŸ’¥ Verification failed:', error);
    process.exit(1);
  });
```

**ì‹¤í–‰**:
```bash
npx ts-node backend/scripts/verify-search-index.ts
```

---

## âœ… v3.1 FINAL ë°°í¬ ì²´í¬ë¦¬ìŠ¤íŠ¸

### A. TOC (í•„ìˆ˜)

- [ ] `slugify()` ë¹ˆ ê°’ fallback í…ŒìŠ¤íŠ¸
- [ ] ê¸°ì¡´ ID ë³´ì¡´ ë¡œì§ E2E í…ŒìŠ¤íŠ¸
- [ ] DOMPurify `addHook` êµ¬í˜„ í™•ì¸
- [ ] sanitize í›„ headings ì •í•©ì„± ê²€ì¦ (dev í™˜ê²½)

### B. Auth (í•„ìˆ˜)

- [ ] CSRF í† í° Double Submit êµ¬í˜„
- [ ] CORS `allowedHeaders`ì— `X-CSRF-Token` ì¶”ê°€
- [ ] SSR ì„œë²„ ë‚´ë¶€ í˜¸ì¶œ `X-Internal-Request` í—¤ë” ì„¤ì •
- [ ] `INTERNAL_REQUEST_SECRET` í™˜ê²½ë³€ìˆ˜ ì„¤ì •
- [ ] Origin Guard ì½”ë“œ ì™„ì „ ì œê±°

### C/D. CSP (í•„ìˆ˜)

- [ ] ì„œë“œíŒŒí‹° ìŠ¤í¬ë¦½íŠ¸ ë„ë©”ì¸ ëª©ë¡ í™•ì •
- [ ] inline script ì¡´ì¬ ì—¬ë¶€ í™•ì¸
- [ ] nonce ì ìš© ë²”ìœ„ ëª…í™•í™”

### E. Search (í•„ìˆ˜)

- [ ] pg_trgm Extension ì„¤ì¹˜ (DBA/Infra)
- [ ] Migration fallback í…ŒìŠ¤íŠ¸
- [ ] `plain_text` vs `plainText` ì»¬ëŸ¼ëª… í™•ì¸
- [ ] **ì¿¼ë¦¬ í”Œëœ ê²€ì¦ ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰** â­
- [ ] ì¸ë±ìŠ¤ ì‚¬ìš© ì—¬ë¶€ í™•ì¸

### ì¶”ê°€ (ê¶Œì¥)

- [ ] DOMPurify Hook íšŒê·€ í…ŒìŠ¤íŠ¸
- [ ] CSRF í† í° ë§Œë£Œ ì²˜ë¦¬
- [ ] ê²€ìƒ‰ ê²°ê³¼ ì—†ìŒ UI
- [ ] ê²€ìƒ‰ì–´ ìµœì†Œ ê¸¸ì´ UX

---

## ğŸ“Š ë³€ê²½ ì‚¬í•­ ìš”ì•½ (REVISED â†’ FINAL)

| í•­ëª© | REVISED ë¬¸ì œ | FINAL í•´ê²° |
|------|-------------|-----------|
| **slugify** | ë¹ˆ ê°’ â†’ ë¹ˆ ID | âœ… `'section'` fallback |
| **ê¸°ì¡´ ID** | ë¬´ì¡°ê±´ ë®ì–´ì”€ | âœ… ìœ íš¨í•˜ë©´ ë³´ì¡´ |
| **DOMPurify** | Hook ì ìš© ë°©ì‹ ì˜¤ë¥˜ | âœ… `addHook()` ì •í™• êµ¬í˜„ |
| **Origin Guard** | SSR ê¹¨ì§ | âœ… ì œê±°, CSRFë¡œ ëŒ€ì²´ |
| **CSRF** | ì—†ìŒ | âœ… Double Submit êµ¬í˜„ |
| **CSP** | ì„œë“œíŒŒí‹° ë¯¸ëª…ì‹œ | âœ… ë„ë©”ì¸ ëª©ë¡ ëª…í™•í™” |
| **Search** | ì»¬ëŸ¼ëª… ë¶ˆëª…í™• | âœ… `plainText` í™•ì • + í”Œëœ ê²€ì¦ |

---

**ë¬¸ì„œ ë²„ì „**: 3.1 FINAL
**ì‘ì„±ì¼**: 2025-12-30
**ê²€ì¦ ìƒíƒœ**: í”„ë¡œë•ì…˜ ë°°í¬ ê°€ëŠ¥
**ì˜ˆìƒ ì‘ì—… ì‹œê°„**: 8-10ì‹œê°„ (ì²´í¬ë¦¬ìŠ¤íŠ¸ ì „ì²´)

**ë‹¤ìŒ ë‹¨ê³„**: ì²´í¬ë¦¬ìŠ¤íŠ¸ ì™„ë£Œ í›„ ìŠ¤í…Œì´ì§• í™˜ê²½ ë°°í¬ â†’ ì¿¼ë¦¬ í”Œëœ ê²€ì¦ â†’ í”„ë¡œë•ì…˜ ë°°í¬