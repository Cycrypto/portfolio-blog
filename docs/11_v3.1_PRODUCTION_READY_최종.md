# v3.1 PRODUCTION READY - ìµœì¢… ë°°í¬íŒ

## ğŸ“‹ ë¬¸ì„œ ì •ë³´

- **ì‘ì„±ì¼**: 2025-12-30
- **ë²„ì „**: 3.1 PRODUCTION READY (ë°°í¬ ì™„ì„±)
- **ì´ì „ ë²„ì „**: 3.1 FINAL PATCH â†’ ìš´ì˜ ì•ˆì •ì„± ë³´ì™„
- **ìƒíƒœ**: í”„ë¡œë•ì…˜ ë°°í¬ ê°€ëŠ¥

---

## ğŸ¯ PRODUCTION READY ìµœì¢… ìˆ˜ì •

| í•­ëª© | FINAL PATCH ë¬¸ì œ | PRODUCTION READY í•´ê²° |
|------|-----------------|---------------------|
| **CSRF ì˜ˆì‹œ** | GETì— CSRF í—¤ë” (í˜¼ì„ ) | âœ… Mutationë§Œ ëª…í™•íˆ |
| **DOMPurify** | ìš°íšŒ ë²¡í„° ë¯¸ì°¨ë‹¨ | âœ… normalize + srcset |
| **pg_trgm ìºì‹œ** | 1íšŒ ê³ ì • (ì¬í™•ì¸ X) | âœ… TTL ì¬í™•ì¸ |
| **clearCookie** | ì˜µì…˜ ë¶ˆëª…í™• | âœ… domain/pathë§Œ í•„ìˆ˜ |
| **ê¸°ì¡´ ID** | ì •ê·œì‹ ê°•ê²½ | âœ… ì (.) í—ˆìš© |
| **CSP API URL** | path í¬í•¨ ê°€ëŠ¥ | âœ… origin ì •ê·œí™” |

---

## ğŸš¨ MUST 1. CSRF í† í° (ìµœì¢… - Mutationë§Œ ëª…í™•íˆ)

### CSRF Guard (ë³€ê²½ ì—†ìŒ)

```typescript
// backend/src/common/guards/csrf.guard.ts
import { Injectable, CanActivate, ExecutionContext, ForbiddenException } from '@nestjs/common';
import { Request } from 'express';

@Injectable()
export class CsrfGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest<Request>();

    // âœ… GET/HEAD/OPTIONSëŠ” ê²€ì¦ ì œì™¸
    if (['GET', 'HEAD', 'OPTIONS'].includes(request.method)) {
      return true;
    }

    // âœ… Double Submit Cookie ê²€ì¦
    const csrfTokenFromCookie = request.cookies['csrf-token'];
    const csrfTokenFromHeader = request.headers['x-csrf-token'] as string;

    if (!csrfTokenFromCookie || !csrfTokenFromHeader) {
      throw new ForbiddenException('CSRF token missing');
    }

    if (csrfTokenFromCookie !== csrfTokenFromHeader) {
      throw new ForbiddenException('CSRF token mismatch');
    }

    return true;
  }
}
```

### âœ… SSR ì¸ì¦ í™•ì¸ (GET - CSRF ë¶ˆí•„ìš”)

```typescript
// frontend/app/admin/layout.tsx (Server Component)
import { redirect } from 'next/navigation'
import { cookies } from 'next/headers'

export default async function AdminLayout({ children }: { children: React.ReactNode }) {
  const cookieStore = await cookies()
  const token = cookieStore.get('auth-token')?.value

  if (!token) {
    redirect('/login')
  }

  // âœ… PRODUCTION READY: GET ìš”ì²­ì€ CSRF ë¶ˆí•„ìš”
  try {
    const response = await fetch(`${process.env.API_URL}/auth/me`, {
      headers: {
        Cookie: `auth-token=${token}`,
        // âŒ ì œê±°: X-CSRF-Token (GETì€ ê²€ì¦ ì•ˆ í•¨)
      },
      cache: 'no-store',
    })

    if (!response.ok) {
      redirect('/login')
    }
  } catch (error) {
    redirect('/login')
  }

  return <>{children}</>
}
```

### âœ… SSR Mutation (POST/PATCH/DELETE - CSRF í•„ìˆ˜)

```typescript
// frontend/app/admin/posts/actions.ts (Server Action)
'use server'

import { cookies } from 'next/headers'
import { revalidatePath } from 'next/cache'

export async function createPostAction(formData: FormData) {
  const cookieStore = await cookies()
  const csrfToken = cookieStore.get('csrf-token')?.value

  if (!csrfToken) {
    throw new Error('CSRF token missing')
  }

  // âœ… PRODUCTION READY: POSTëŠ” CSRF í•„ìˆ˜
  const response = await fetch(`${process.env.API_URL}/posts`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRF-Token': csrfToken,  // âœ… Mutationì€ CSRF ê²€ì¦
      Cookie: cookieStore.toString(),
    },
    body: JSON.stringify({
      title: formData.get('title'),
      content: formData.get('content'),
      category: formData.get('category'),
      status: 'published',
    }),
  })

  if (!response.ok) {
    const error = await response.json()
    throw new Error(error.message || 'Failed to create post')
  }

  revalidatePath('/admin/posts')
  return response.json()
}

export async function updatePostAction(id: string, formData: FormData) {
  const cookieStore = await cookies()
  const csrfToken = cookieStore.get('csrf-token')?.value

  if (!csrfToken) {
    throw new Error('CSRF token missing')
  }

  const response = await fetch(`${process.env.API_URL}/posts/${id}`, {
    method: 'PATCH',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRF-Token': csrfToken,
      Cookie: cookieStore.toString(),
    },
    body: JSON.stringify({
      title: formData.get('title'),
      content: formData.get('content'),
    }),
  })

  if (!response.ok) {
    throw new Error('Failed to update post')
  }

  revalidatePath('/admin/posts')
  revalidatePath(`/admin/posts/${id}`)
  return response.json()
}

export async function deletePostAction(id: string) {
  const cookieStore = await cookies()
  const csrfToken = cookieStore.get('csrf-token')?.value

  if (!csrfToken) {
    throw new Error('CSRF token missing')
  }

  const response = await fetch(`${process.env.API_URL}/posts/${id}`, {
    method: 'DELETE',
    headers: {
      'X-CSRF-Token': csrfToken,
      Cookie: cookieStore.toString(),
    },
  })

  if (!response.ok) {
    throw new Error('Failed to delete post')
  }

  revalidatePath('/admin/posts')
}
```

---

## ğŸš¨ MUST 2. logout clearCookie (ìµœì¢… - domain/path í•„ìˆ˜)

### âœ… PRODUCTION READY: clearCookie ì •í™•í•œ ì˜µì…˜

```typescript
// backend/src/auth/auth.controller.ts
import { Controller, Post, HttpCode, Res } from '@nestjs/common';
import { Response } from 'express';

@Controller('auth')
export class AuthController {
  @Post('logout')
  @HttpCode(200)
  async logout(@Res({ passthrough: true }) response: Response) {
    // âœ… PRODUCTION READY: domain ì •ê·œí™”
    const rawDomain = process.env.COOKIE_DOMAIN?.trim();
    const cookieDomain = process.env.NODE_ENV === 'production' && rawDomain
      ? rawDomain
      : undefined;

    // âœ… domain/path ì¼ì¹˜ (í•„ìˆ˜)
    // secure/sameSite ì¼ì¹˜ (ê¶Œì¥)
    response.clearCookie('auth-token', {
      domain: cookieDomain,  // âœ… í•„ìˆ˜
      path: '/',             // âœ… í•„ìˆ˜
      secure: process.env.NODE_ENV === 'production',  // âœ… ê¶Œì¥
      sameSite: 'strict',    // âœ… ê¶Œì¥
      // httpOnlyëŠ” clearCookieì—ì„œ ì˜ë¯¸ ì—†ìŒ (ìƒëµ ê°€ëŠ¥)
    });

    response.clearCookie('csrf-token', {
      domain: cookieDomain,
      path: '/',
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
    });

    return { message: 'Logout successful' };
  }
}
```

---

## ğŸš¨ MUST 3. DOMPurify (ìµœì¢… - ìš°íšŒ ë²¡í„° ì°¨ë‹¨)

### âœ… PRODUCTION READY: ê²¬ê³ í•œ Hook êµ¬í˜„

```typescript
// backend/src/posts/utils/content-renderer.ts
import { JSDOM } from 'jsdom';
import DOMPurify from 'isomorphic-dompurify';

const window = new JSDOM('').window;
const purify = DOMPurify(window);

// âœ… PRODUCTION READY: ìš°íšŒ ë²¡í„° ì°¨ë‹¨
purify.addHook('uponSanitizeAttribute', (node, data) => {
  const attrName = data.attrName;
  const rawValue = String(data.attrValue || '');

  // âœ… ê°’ ì •ê·œí™” (ê³µë°±/ëŒ€ì†Œë¬¸ì ìš°íšŒ ë°©ì§€)
  const attrValue = rawValue.trim().toLowerCase();

  // âœ… <img src>: ì•ˆì „í•œ ì´ë¯¸ì§€ë§Œ í—ˆìš©
  if (node.tagName === 'IMG' && attrName === 'src') {
    // PNG/JPG/GIF/WebPë§Œ í—ˆìš© (SVG ì œì™¸)
    const safeImagePattern = /^data:image\/(png|jpe?g|gif|webp);base64,/i;

    if (safeImagePattern.test(attrValue)) {
      return;  // í—ˆìš©
    }

    // data:image/* ì¤‘ í—ˆìš©ë˜ì§€ ì•Šì€ ê²ƒ ì°¨ë‹¨
    if (attrValue.startsWith('data:image/')) {
      data.keepAttr = false;
      return;
    }
  }

  // âœ… <img srcset>: ëª…ì‹œì  ì°¨ë‹¨ (í—ˆìš© ì•ˆ í•¨)
  if (node.tagName === 'IMG' && attrName === 'srcset') {
    data.keepAttr = false;
    return;
  }

  // âœ… <a href>: javascript:, data: ì°¨ë‹¨
  if (attrName === 'href') {
    if (attrValue.startsWith('javascript:') || attrValue.startsWith('data:')) {
      data.keepAttr = false;
    }
  }

  // âœ… ëª¨ë“  src: javascript: ì°¨ë‹¨
  if (attrName === 'src') {
    if (attrValue.startsWith('javascript:')) {
      data.keepAttr = false;
    }
  }
});

const PURIFY_CONFIG = {
  ALLOWED_TAGS: [
    'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
    'p', 'br', 'strong', 'em', 'u', 's',
    'a', 'img',
    'ul', 'ol', 'li',
    'blockquote', 'code', 'pre',
    'table', 'thead', 'tbody', 'tr', 'th', 'td',
    'div', 'span',
  ],
  ALLOWED_ATTR: [
    'href', 'src', 'alt', 'title', 'class',
    'target', 'rel', 'loading', 'id',
    // âŒ srcset ì œì™¸ (Hookì—ì„œ ì°¨ë‹¨)
  ],
  ALLOW_DATA_ATTR: false,

  // âœ… http/https/mailtoë§Œ í—ˆìš©
  ALLOWED_URI_REGEXP: /^(?:(?:https?|mailto):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i,
};
```

### í…ŒìŠ¤íŠ¸: ìš°íšŒ ë²¡í„° ì°¨ë‹¨

```typescript
// backend/test/utils/content-renderer.spec.ts
describe('DOMPurify Security (PRODUCTION READY)', () => {
  it('should block data:image/svg+xml (lowercase)', () => {
    const svg = 'data:image/svg+xml,%3Csvg%3E%3Cscript%3Ealert(1)%3C/script%3E%3C/svg%3E';
    // ... (ì°¨ë‹¨ í™•ì¸)
  });

  it('should block Data:Image/SVG+XML (uppercase)', () => {
    const svg = 'Data:Image/SVG+XML,%3Csvg%3E%3Cscript%3Ealert(1)%3C/script%3E%3C/svg%3E';
    // ... (ì°¨ë‹¨ í™•ì¸)
  });

  it('should block data:image with spaces', () => {
    const svg = '  data:image/svg+xml  ,%3Csvg%3E';
    // ... (ì°¨ë‹¨ í™•ì¸)
  });

  it('should block img[srcset]', () => {
    const html = '<img srcset="evil.jpg 1x, evil2.jpg 2x">';
    const sanitized = purify.sanitize(html, PURIFY_CONFIG);

    expect(sanitized).not.toContain('srcset');
  });

  it('should allow safe data:image/png', () => {
    const png = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==';
    // ... (í—ˆìš© í™•ì¸)
  });
});
```

---

## ğŸ“ SHOULD 1. ê¸°ì¡´ ID ìœ íš¨ì„± (ìµœì¢… - ì  í—ˆìš©)

### âœ… PRODUCTION READY: í˜„ì‹¤ì ì¸ ì •ê·œì‹

```typescript
// backend/src/posts/utils/heading-processor.ts
import { JSDOM } from 'jsdom';

/**
 * IDê°€ URL fragmentë¡œ ì‚¬ìš© ê°€ëŠ¥í•œì§€ ê²€ì¦
 * âœ… PRODUCTION READY: ì (.) í—ˆìš© (section-1.2 ê°™ì€ ID)
 */
function isValidId(id: string): boolean {
  // ì˜ë¬¸/ìˆ«ì/í•˜ì´í”ˆ/ì–¸ë”ìŠ¤ì½”ì–´/ì /í•œê¸€ í—ˆìš©
  return /^[a-z0-9ê°€-í£._-]+$/i.test(id);
}

export function slugify(text: string): string {
  const slug = text
    .toLowerCase()
    .trim()
    .replace(/[^a-z0-9ê°€-í£\s-]/g, '')
    .replace(/\s+/g, '-')
    .replace(/-+/g, '-')
    .replace(/^-|-$/g, '');

  if (!slug) {
    return 'section';
  }

  return slug;
}

export function injectHeadingIds(html: string): {
  html: string;
  headings: Array<{ level: number; text: string; id: string }>;
} {
  const dom = new JSDOM(html);
  const document = dom.window.document;
  const headingElements = document.querySelectorAll('h1, h2, h3, h4, h5, h6');

  const headings: Array<{ level: number; text: string; id: string }> = [];
  const usedIds = new Set<string>();

  headingElements.forEach((element) => {
    const level = parseInt(element.tagName[1]);
    const text = element.textContent?.trim() || '';

    if (!text) {
      return;
    }

    const existingId = element.getAttribute('id');
    let finalId: string;

    // âœ… PRODUCTION READY: ê¸°ì¡´ ID ìœ íš¨ì„± ê²€ì¦
    if (existingId && existingId.trim() &&
        isValidId(existingId.trim()) &&
        !usedIds.has(existingId.trim())) {
      finalId = existingId.trim();

      if (process.env.NODE_ENV === 'development') {
        console.log(`âœ… Preserving valid ID: ${finalId}`);
      }
    } else {
      let baseId = slugify(text);

      if (usedIds.has(baseId)) {
        let counter = 2;
        while (usedIds.has(`${baseId}-${counter}`)) {
          counter++;
        }
        finalId = `${baseId}-${counter}`;
      } else {
        finalId = baseId;
      }

      if (existingId && !isValidId(existingId)) {
        console.warn(`âš ï¸ Invalid ID replaced: "${existingId}" â†’ "${finalId}"`);
      }
    }

    usedIds.add(finalId);
    element.setAttribute('id', finalId);
    headings.push({ level, text, id: finalId });
  });

  return {
    html: document.body.innerHTML,
    headings,
  };
}
```

---

## ğŸ“ SHOULD 2. pg_trgm ìºì‹± (ìµœì¢… - TTL ì¬í™•ì¸)

### âœ… PRODUCTION READY: TTL ê¸°ë°˜ ì¬í™•ì¸

```typescript
// backend/src/posts/service/posts.service.ts
import { Injectable, OnModuleInit } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Post } from '../entity/post.entity';

@Injectable()
export class PostsService implements OnModuleInit {
  // âœ… PRODUCTION READY: TTL ìºì‹œ
  private pgTrgmAvailable: boolean = false;
  private lastCheckedAt: number = 0;
  private readonly cacheTtlMs: number = 5 * 60 * 1000;  // 5ë¶„

  constructor(
    @InjectRepository(Post)
    private readonly postRepository: Repository<Post>,
  ) {}

  async onModuleInit() {
    // ë¶€íŒ… ì‹œ 1íšŒ ì²´í¬
    await this.checkPgTrgm();
  }

  /**
   * âœ… PRODUCTION READY: TTL ê¸°ë°˜ ì¬í™•ì¸
   */
  private async checkPgTrgm(): Promise<boolean> {
    const now = Date.now();

    // TTL ë‚´ë©´ ìºì‹œ ì‚¬ìš©
    if (now - this.lastCheckedAt < this.cacheTtlMs) {
      return this.pgTrgmAvailable;
    }

    // TTL ë§Œë£Œ â†’ ì¬í™•ì¸
    try {
      const result = await this.postRepository.query(
        `SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm'`
      );

      this.pgTrgmAvailable = result.length > 0;
      this.lastCheckedAt = now;

      console.log(`âœ… pg_trgm check: ${this.pgTrgmAvailable} (cached for ${this.cacheTtlMs}ms)`);
    } catch (error) {
      console.warn('âš ï¸ pg_trgm check failed:', error.message);
      this.pgTrgmAvailable = false;
      this.lastCheckedAt = now;
    }

    return this.pgTrgmAvailable;
  }

  async getPosts(
    keyword: string = '',
    tag: string = '',
    page: number = 1,
    pageSize: number = 10
  ): Promise<Post[]> {
    const queryBuilder = this.postRepository
      .createQueryBuilder('post')
      .leftJoinAndSelect('post.tags', 'tag')
      .where('post.status = :status', { status: 'published' });

    if (keyword && keyword.trim().length >= 2) {
      const cleanKeyword = keyword.trim();

      // âœ… PRODUCTION READY: TTL ì¬í™•ì¸
      const usePgTrgm = await this.checkPgTrgm();

      if (usePgTrgm) {
        // pg_trgm ê²€ìƒ‰
        queryBuilder.andWhere(
          '(post.plainText % :keyword OR post.title % :keyword)',
          { keyword: cleanKeyword }
        );
        queryBuilder.addSelect(
          `(similarity(post.title, :keyword) * 2 + similarity(post.plainText, :keyword))`,
          'relevance'
        );
        queryBuilder.setParameter('keyword', cleanKeyword);
        queryBuilder.orderBy('relevance', 'DESC');
      } else {
        // Fallback: ILIKE
        queryBuilder.andWhere(
          '(post.title ILIKE :keywordPattern OR post.plainText ILIKE :keywordPattern)',
          { keywordPattern: `%${cleanKeyword}%` }
        );
        queryBuilder.orderBy('post.publishDate', 'DESC');
      }
    } else if (!keyword) {
      queryBuilder.orderBy('post.publishDate', 'DESC');
    }

    if (tag) {
      queryBuilder.andWhere('tag.name = :tag', { tag });
    }

    queryBuilder
      .skip((page - 1) * pageSize)
      .take(pageSize);

    return queryBuilder.getMany();
  }

  async getPostsCount(keyword: string = '', tag: string = ''): Promise<number> {
    const queryBuilder = this.postRepository
      .createQueryBuilder('post')
      .where('post.status = :status', { status: 'published' });

    if (keyword && keyword.trim().length >= 2) {
      const cleanKeyword = keyword.trim();
      const usePgTrgm = await this.checkPgTrgm();

      if (usePgTrgm) {
        queryBuilder.andWhere(
          '(post.plainText % :keyword OR post.title % :keyword)',
          { keyword: cleanKeyword }
        );
      } else {
        queryBuilder.andWhere(
          '(post.title ILIKE :keywordPattern OR post.plainText ILIKE :keywordPattern)',
          { keywordPattern: `%${cleanKeyword}%` }
        );
      }
    }

    if (tag) {
      queryBuilder
        .leftJoin('post.tags', 'tag')
        .andWhere('tag.name = :tag', { tag });
    }

    return queryBuilder.getCount();
  }
}
```

---

## ğŸ“ SHOULD 3. CSP connect-src (ìµœì¢… - origin ì •ê·œí™”)

### âœ… PRODUCTION READY: origin ì¶”ì¶œ

```typescript
// frontend/middleware.ts
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

function generateNonce(): string {
  const array = new Uint8Array(16);
  crypto.getRandomValues(array);

  const base64 = btoa(String.fromCharCode(...array));
  return base64
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=/g, '');
}

export function middleware(request: NextRequest) {
  const nonce = generateNonce();
  const response = NextResponse.next();

  const scriptSources = [
    "'self'",
    `'nonce-${nonce}'`,
  ].join(' ');

  // âœ… PRODUCTION READY: origin ì •ê·œí™”
  const apiUrl = process.env.NEXT_PUBLIC_API_URL;
  let apiOrigin = '';

  if (apiUrl) {
    try {
      const url = new URL(apiUrl);
      apiOrigin = url.origin;  // https://api.example.com (path ì œê±°)
    } catch (error) {
      console.warn('âš ï¸ Invalid NEXT_PUBLIC_API_URL:', apiUrl);
    }
  }

  const connectSrc = apiOrigin
    ? `'self' ${apiOrigin}`
    : "'self'";

  const cspHeader = `
    default-src 'self';
    script-src ${scriptSources};
    style-src 'self' 'unsafe-inline';
    img-src 'self' data: https:;
    font-src 'self' data:;
    connect-src ${connectSrc};
    frame-ancestors 'none';
    base-uri 'self';
    form-action 'self';
  `.replace(/\s{2,}/g, ' ').trim();

  response.headers.set('Content-Security-Policy', cspHeader);
  response.headers.set('X-Frame-Options', 'DENY');
  response.headers.set('X-Content-Type-Options', 'nosniff');
  response.headers.set('X-Nonce', nonce);

  return response;
}

export const config = {
  matcher: '/:path*',
}
```

---

## âœ… PRODUCTION READY ìµœì¢… ì²´í¬ë¦¬ìŠ¤íŠ¸

### MUST (ë°°í¬ ë¸”ë¡œì»¤)

**ë³´ì•ˆ**:
- [ ] CSRF Guard ë‚´ë¶€ ìš°íšŒ ì œê±° í™•ì¸
- [ ] SSR GET ìš”ì²­ì— CSRF í—¤ë” ì—†ìŒ í™•ì¸
- [ ] SSR Mutationì— CSRF í—¤ë” ìˆìŒ í™•ì¸
- [ ] logout clearCookie domain/path ì¼ì¹˜ í™•ì¸
- [ ] DOMPurify SVG ì°¨ë‹¨ í…ŒìŠ¤íŠ¸ í†µê³¼
- [ ] DOMPurify ëŒ€ì†Œë¬¸ì/ê³µë°± ìš°íšŒ ì°¨ë‹¨
- [ ] img[srcset] ì°¨ë‹¨ í™•ì¸

**í™˜ê²½ë³€ìˆ˜**:
- [ ] `INTERNAL_REQUEST_SECRET` ì™„ì „ ì œê±°
- [ ] `COOKIE_DOMAIN` ì •ê·œí™” (ë¹ˆ ê°’ â†’ undefined)
- [ ] `NEXT_PUBLIC_API_URL` originë§Œ ì‚¬ìš© í™•ì¸

### SHOULD (ì•ˆì •ì„±)

- [ ] ê¸°ì¡´ ID ìœ íš¨ì„± ê²€ì¦ (ì  í—ˆìš©)
- [ ] pg_trgm TTL ìºì‹± (5ë¶„)
- [ ] CSP connect-src origin ì •ê·œí™”
- [ ] Server Action ì—ëŸ¬ ì²˜ë¦¬

---

## ğŸ“Š ìµœì¢… ë³€ê²½ ì‚¬í•­

| í•­ëª© | FINAL PATCH | PRODUCTION READY |
|------|------------|------------------|
| **CSRF ì˜ˆì‹œ** | GETì— CSRF í—¤ë” | âœ… Mutationë§Œ ëª…í™• |
| **DOMPurify** | ê¸°ë³¸ íŒ¨í„´ | âœ… normalize + srcset |
| **pg_trgm** | 1íšŒ ìºì‹± | âœ… TTL 5ë¶„ ì¬í™•ì¸ |
| **clearCookie** | ëª¨ë“  ì˜µì…˜ | âœ… domain/path í•„ìˆ˜ë§Œ |
| **ê¸°ì¡´ ID** | `[a-z0-9ê°€-í£_-]` | âœ… ì (.) ì¶”ê°€ í—ˆìš© |
| **CSP** | path í¬í•¨ ê°€ëŠ¥ | âœ… originë§Œ ì¶”ì¶œ |

---

**ìµœì¢… ë²„ì „**: 3.1 PRODUCTION READY
**ì‘ì„±ì¼**: 2025-12-30
**ìƒíƒœ**: í”„ë¡œë•ì…˜ ë°°í¬ ê°€ëŠ¥ âœ…

**ë‹¤ìŒ ë‹¨ê³„**:
1. ì²´í¬ë¦¬ìŠ¤íŠ¸ ì™„ë£Œ
2. ìŠ¤í…Œì´ì§• ë°°í¬
3. í†µí•© í…ŒìŠ¤íŠ¸
4. í”„ë¡œë•ì…˜ ë°°í¬