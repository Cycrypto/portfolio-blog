# v3.1 FINAL PATCH - ë³´ì•ˆ ì·¨ì•½ì  ìˆ˜ì •

## ğŸ“‹ íŒ¨ì¹˜ ì •ë³´

- **ì‘ì„±ì¼**: 2025-12-30
- **ë²„ì „**: 3.1 FINAL PATCH
- **ì´ì „ ë²„ì „**: 3.1 FINAL â†’ ë³´ì•ˆ ì·¨ì•½ì  ì œê±°
- **íŒ¨ì¹˜ ëŒ€ìƒ**: MUST 3ê°œ, SHOULD 5ê°œ

---

## ğŸš¨ MUST ìˆ˜ì •ì‚¬í•­ (ì¦‰ì‹œ ì ìš©)

### MUST 1. CSRF ë‚´ë¶€ ìš°íšŒ ì œê±° (ë³´ì•ˆ ì·¨ì•½ì )

#### ë¬¸ì œì 

**í˜„ì¬ v3.1 FINAL ì½”ë“œ**:
```typescript
// âŒ ì·¨ì•½: INTERNAL_REQUEST_SECRET ìœ ì¶œ ì‹œ CSRF ì™„ì „ ìš°íšŒ
const internalHeader = request.headers['x-internal-request'];
if (internalHeader === process.env.INTERNAL_REQUEST_SECRET) {
  return true;  // ê³µê²©ìê°€ í—¤ë”ë§Œ ì•Œë©´ ëª¨ë“  ë³´í˜¸ ìš°íšŒ
}
```

**ìœ„í—˜ì„±**:
1. `frontend/.env.local`ì— ë™ì¼ ì‹œí¬ë¦¿ ì €ì¥ â†’ í´ë¼ì´ì–¸íŠ¸ ë¹Œë“œ ì‚°ì¶œë¬¼ ìœ ì¶œ ê°€ëŠ¥
2. `NEXT_PUBLIC_` ì ‘ë‘ì‚¬ ì‹¤ìˆ˜ë¡œ ë…¸ì¶œ ê°€ëŠ¥
3. ë¡œê·¸/í™˜ê²½ë³€ìˆ˜ ì„¤ì • ì‹¤ìˆ˜ë¡œ ìœ ì¶œ ì‹œ **ëª¨ë“  CSRF ë³´í˜¸ ë¬´ë ¥í™”**

#### í•´ê²°: SSRì—ì„œë„ CSRF í† í° ì‚¬ìš©

**âœ… PATCH: CSRF Guard ìˆ˜ì •**

```typescript
// backend/src/common/guards/csrf.guard.ts
import { Injectable, CanActivate, ExecutionContext, ForbiddenException } from '@nestjs/common';
import { Request } from 'express';

@Injectable()
export class CsrfGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean {
    const request = context.switchToHttp().getRequest<Request>();

    // âœ… GET/HEAD/OPTIONSëŠ” CSRF ê²€ì¦ ì œì™¸ (ì½ê¸° ì „ìš©)
    if (['GET', 'HEAD', 'OPTIONS'].includes(request.method)) {
      return true;
    }

    // âœ… PATCH: ë‚´ë¶€ ìš°íšŒ ì™„ì „ ì œê±°
    // âŒ ì œê±°ë¨: X-Internal-Request ë°”ì´íŒ¨ìŠ¤

    // âœ… Double Submit Cookie ê²€ì¦ (ëª¨ë“  ìš”ì²­ ë™ì¼)
    const csrfTokenFromCookie = request.cookies['csrf-token'];
    const csrfTokenFromHeader = request.headers['x-csrf-token'] as string;

    if (!csrfTokenFromCookie || !csrfTokenFromHeader) {
      throw new ForbiddenException('CSRF token missing');
    }

    if (csrfTokenFromCookie !== csrfTokenFromHeader) {
      throw new ForbiddenException('CSRF token mismatch');
    }

    return true;
  }
}
```

**âœ… PATCH: SSRì—ì„œ CSRF í† í° ì‚¬ìš©**

```typescript
// frontend/app/admin/layout.tsx (Server Component)
import { redirect } from 'next/navigation'
import { cookies } from 'next/headers'

export default async function AdminLayout({ children }: { children: React.ReactNode }) {
  const cookieStore = await cookies()
  const token = cookieStore.get('auth-token')?.value
  const csrfToken = cookieStore.get('csrf-token')?.value  // âœ… CSRF í† í° ì½ê¸°

  if (!token) {
    redirect('/login')
  }

  // âœ… PATCH: SSRì—ì„œë„ CSRF í† í° ì‚¬ìš©
  try {
    const response = await fetch(`${process.env.API_URL}/auth/me`, {
      headers: {
        Cookie: `auth-token=${token}; csrf-token=${csrfToken}`,
        'X-CSRF-Token': csrfToken || '',  // âœ… CSRF í—¤ë” ì¶”ê°€
      },
      cache: 'no-store',
    })

    if (!response.ok) {
      redirect('/login')
    }
  } catch (error) {
    redirect('/login')
  }

  return <>{children}</>
}
```

**âœ… PATCH: Server Actionsì—ì„œ CSRF ì‚¬ìš©**

```typescript
// frontend/app/admin/posts/actions.ts (Server Action ì˜ˆì‹œ)
'use server'

import { cookies } from 'next/headers'
import { revalidatePath } from 'next/cache'

export async function createPostAction(formData: FormData) {
  const cookieStore = await cookies()
  const csrfToken = cookieStore.get('csrf-token')?.value

  if (!csrfToken) {
    throw new Error('CSRF token missing')
  }

  const response = await fetch(`${process.env.API_URL}/posts`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRF-Token': csrfToken,  // âœ… SSRë„ ë™ì¼í•œ ê²€ì¦
      Cookie: cookieStore.toString(),
    },
    body: JSON.stringify({
      title: formData.get('title'),
      content: formData.get('content'),
      // ...
    }),
  })

  if (!response.ok) {
    throw new Error('Failed to create post')
  }

  revalidatePath('/admin/posts')
  return response.json()
}
```

**âœ… í™˜ê²½ë³€ìˆ˜ ì •ë¦¬**

```env
# backend/.env
# âŒ ì œê±°: INTERNAL_REQUEST_SECRET (ë” ì´ìƒ ì‚¬ìš© ì•ˆ í•¨)

# frontend/.env.local
# âŒ ì œê±°: INTERNAL_REQUEST_SECRET
```

---

### MUST 2. logout clearCookie ì˜µì…˜ ë¶ˆì¼ì¹˜ (ì¿ í‚¤ ë¯¸ì‚­ì œ)

#### ë¬¸ì œì 

**í˜„ì¬ v3.1 FINAL ì½”ë“œ**:
```typescript
// âŒ ì¿ í‚¤ ì„¤ì • ì‹œ domain/path ì‚¬ìš©í–ˆì§€ë§Œ
response.cookie('auth-token', access_token, {
  domain: cookieDomain,
  path: '/',
  // ...
});

// âŒ ì‚­ì œ ì‹œ ì˜µì…˜ ì—†ìŒ â†’ ë¸Œë¼ìš°ì €ì— ì¿ í‚¤ ë‚¨ìŒ
response.clearCookie('auth-token');
response.clearCookie('csrf-token');
```

**ìœ„í—˜ì„±**:
- ë¡œê·¸ì•„ì›ƒ í›„ì—ë„ ì¿ í‚¤ê°€ ë¸Œë¼ìš°ì €ì— ë‚¨ì•„ ì¬ì‚¬ìš© ê°€ëŠ¥
- íŠ¹íˆ ì„œë¸Œë„ë©”ì¸ ê³µìœ  ì‹œ (`domain: '.example.com'`) ë¬¸ì œ ì‹¬ê°

#### í•´ê²°: clearCookie ì˜µì…˜ ì¼ì¹˜

**âœ… PATCH: logout ìˆ˜ì •**

```typescript
// backend/src/auth/auth.controller.ts
import { Controller, Post, HttpCode, Res } from '@nestjs/common';
import { Response } from 'express';

@Controller('auth')
export class AuthController {
  // ... login ë©”ì„œë“œ

  @Post('logout')
  @HttpCode(200)
  async logout(@Res({ passthrough: true }) response: Response) {
    // âœ… PATCH: loginê³¼ ë™ì¼í•œ ì˜µì…˜ìœ¼ë¡œ ì‚­ì œ
    const cookieDomain = process.env.NODE_ENV === 'production'
      ? process.env.COOKIE_DOMAIN
      : undefined;

    response.clearCookie('auth-token', {
      domain: cookieDomain,  // âœ… ì¶”ê°€
      path: '/',             // âœ… ì¶”ê°€
      httpOnly: true,        // âœ… ì¶”ê°€ (ì„ íƒì , ë” ì•ˆì „)
      secure: process.env.NODE_ENV === 'production',  // âœ… ì¶”ê°€
      sameSite: 'strict',    // âœ… ì¶”ê°€
    });

    response.clearCookie('csrf-token', {
      domain: cookieDomain,  // âœ… ì¶”ê°€
      path: '/',             // âœ… ì¶”ê°€
      httpOnly: false,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
    });

    return { message: 'Logout successful' };
  }
}
```

**âœ… í™˜ê²½ë³€ìˆ˜ ì„¤ì •**

```env
# backend/.env.production
COOKIE_DOMAIN=.example.com  # ì„œë¸Œë„ë©”ì¸ ê³µìœ  ì‹œ
# ë˜ëŠ”
# COOKIE_DOMAIN=  # ë™ì¼ ë„ë©”ì¸ë§Œ ì‚¬ìš© ì‹œ ë¹„ì›Œë‘ 

# backend/.env.local (ê°œë°œ)
# COOKIE_DOMAINì€ ì„¤ì •í•˜ì§€ ì•ŠìŒ (undefined)
```

---

### MUST 3. data:image SVG ê³µê²© ë²¡í„° (XSS ìœ„í—˜)

#### ë¬¸ì œì 

**í˜„ì¬ v3.1 FINAL ì½”ë“œ**:
```typescript
// âŒ data:image/* ì „ì²´ í—ˆìš©
purify.addHook('uponSanitizeAttribute', (node, data) => {
  if (node.tagName === 'IMG' && data.attrName === 'src') {
    if (data.attrValue.startsWith('data:image/')) {
      return;  // âŒ SVG í¬í•¨ ëª¨ë‘ í—ˆìš©
    }
  }
});
```

**ìœ„í—˜ì„±**:
```html
<!-- âŒ ê³µê²© ê°€ëŠ¥ -->
<img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'%3E
  %3Cscript%3Ealert('XSS')%3C/script%3E%3C/svg%3E">
```

- SVG ë‚´ë¶€ì— `<script>` ì‚½ì… ê°€ëŠ¥
- `<foreignObject>` + HTML ì£¼ì… ê°€ëŠ¥
- ë¸Œë¼ìš°ì €ë³„/ìƒí™©ë³„ XSS ë²¡í„°

#### í•´ê²°: ì•ˆì „í•œ MIMEë§Œ Whitelist

**âœ… PATCH: DOMPurify Hook ìˆ˜ì •**

```typescript
// backend/src/posts/utils/content-renderer.ts
import { JSDOM } from 'jsdom';
import DOMPurify from 'isomorphic-dompurify';

const window = new JSDOM('').window;
const purify = DOMPurify(window);

// âœ… PATCH: ì•ˆì „í•œ ì´ë¯¸ì§€ MIMEë§Œ í—ˆìš©
purify.addHook('uponSanitizeAttribute', (node, data) => {
  const attrName = data.attrName;
  const attrValue = String(data.attrValue || '');

  // âœ… <img src>: PNG/JPG/GIF/WebPë§Œ í—ˆìš© (SVG ì œì™¸)
  if (node.tagName === 'IMG' && attrName === 'src') {
    // âœ… data:image/(png|jpeg|jpg|gif|webp);base64,... ë§Œ í—ˆìš©
    const safeImagePattern = /^data:image\/(png|jpe?g|gif|webp);base64,/i;

    if (safeImagePattern.test(attrValue)) {
      return;  // ì•ˆì „í•œ ì´ë¯¸ì§€ í—ˆìš©
    }

    // âœ… data:image/* ì¤‘ í—ˆìš©ë˜ì§€ ì•Šì€ ê²ƒì€ ì°¨ë‹¨
    if (attrValue.startsWith('data:image/')) {
      data.keepAttr = false;  // SVG ë“± ì°¨ë‹¨
      return;
    }

    // âœ… https://, http:// URLì€ ALLOWED_URI_REGEXPì—ì„œ ì²˜ë¦¬
  }

  // âœ… <a href>: javascript:, data: ì°¨ë‹¨
  if (attrName === 'href') {
    if (attrValue.startsWith('javascript:') || attrValue.startsWith('data:')) {
      data.keepAttr = false;
    }
  }

  // âœ… ëª¨ë“  src: javascript: ì°¨ë‹¨
  if (attrName === 'src') {
    if (attrValue.startsWith('javascript:')) {
      data.keepAttr = false;
    }
  }
});

// âœ… PATCH: ALLOWED_URI_REGEXPì—ì„œ data:image ì œê±° (Hookìœ¼ë¡œë§Œ ì œì–´)
const PURIFY_CONFIG = {
  ALLOWED_TAGS: [
    'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
    'p', 'br', 'strong', 'em', 'u', 's',
    'a', 'img',
    'ul', 'ol', 'li',
    'blockquote', 'code', 'pre',
    'table', 'thead', 'tbody', 'tr', 'th', 'td',
    'div', 'span',
  ],
  ALLOWED_ATTR: [
    'href', 'src', 'alt', 'title', 'class',
    'target', 'rel', 'loading', 'id',
  ],
  ALLOW_DATA_ATTR: false,

  // âœ… PATCH: data:image ì œê±° (http/https/mailtoë§Œ)
  ALLOWED_URI_REGEXP: /^(?:(?:https?|mailto):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i,
};
```

**âœ… í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ì¶”ê°€**

```typescript
// backend/test/utils/content-renderer.spec.ts
import { renderTiptapToHTML } from '../src/posts/utils/content-renderer';

describe('DOMPurify Security (PATCH)', () => {
  it('should block data:image/svg+xml', () => {
    const maliciousSvg = `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'%3E%3Cscript%3Ealert('XSS')%3C/script%3E%3C/svg%3E`;

    const json = {
      type: 'doc',
      content: [{
        type: 'paragraph',
        content: [{
          type: 'image',
          attrs: { src: maliciousSvg }
        }]
      }]
    };

    const { html } = renderTiptapToHTML(json);

    // âœ… SVGëŠ” ì°¨ë‹¨ë˜ì–´ì•¼ í•¨
    expect(html).not.toContain('data:image/svg');
    expect(html).not.toContain('<script>');
  });

  it('should allow safe data:image/png', () => {
    const safePng = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==';

    const json = {
      type: 'doc',
      content: [{
        type: 'paragraph',
        content: [{
          type: 'image',
          attrs: { src: safePng }
        }]
      }]
    };

    const { html } = renderTiptapToHTML(json);

    // âœ… PNGëŠ” í—ˆìš©ë˜ì–´ì•¼ í•¨
    expect(html).toContain('data:image/png;base64');
  });

  it('should block javascript: protocol', () => {
    const maliciousJs = 'javascript:alert("XSS")';

    const json = {
      type: 'doc',
      content: [{
        type: 'paragraph',
        content: [{
          type: 'link',
          attrs: { href: maliciousJs },
          content: [{ type: 'text', text: 'Click' }]
        }]
      }]
    };

    const { html } = renderTiptapToHTML(json);

    // âœ… javascript: ì°¨ë‹¨
    expect(html).not.toContain('javascript:');
  });
});
```

---

## ğŸ“ SHOULD ìˆ˜ì •ì‚¬í•­ (ê¶Œì¥)

### SHOULD 1. ê¸°ì¡´ ID ìœ íš¨ì„± ê²€ì¦

**âœ… PATCH: heading-processor.ts ìˆ˜ì •**

```typescript
// backend/src/posts/utils/heading-processor.ts
import { JSDOM } from 'jsdom';
// âŒ ì œê±°: import crypto from 'crypto'; (ì‚¬ìš©í•˜ì§€ ì•ŠìŒ)

/**
 * IDê°€ URL fragmentë¡œ ì‚¬ìš© ê°€ëŠ¥í•œì§€ ê²€ì¦
 */
function isValidId(id: string): boolean {
  // ê³µë°±, íŠ¹ìˆ˜ë¬¸ì ì œì™¸ (ì˜ë¬¸/ìˆ«ì/í•˜ì´í”ˆ/ì–¸ë”ìŠ¤ì½”ì–´/í•œê¸€ë§Œ)
  return /^[a-z0-9ê°€-í£_-]+$/i.test(id);
}

export function injectHeadingIds(html: string): {
  html: string;
  headings: Array<{ level: number; text: string; id: string }>;
} {
  const dom = new JSDOM(html);
  const document = dom.window.document;
  const headingElements = document.querySelectorAll('h1, h2, h3, h4, h5, h6');

  const headings: Array<{ level: number; text: string; id: string }> = [];
  const usedIds = new Set<string>();

  headingElements.forEach((element) => {
    const level = parseInt(element.tagName[1]);
    const text = element.textContent?.trim() || '';

    if (!text) {
      return;
    }

    // âœ… PATCH: ê¸°ì¡´ ID ìœ íš¨ì„± ê²€ì¦
    const existingId = element.getAttribute('id');
    let finalId: string;

    if (existingId && existingId.trim() &&
        isValidId(existingId.trim()) &&  // âœ… ìœ íš¨ì„± ê²€ì¦ ì¶”ê°€
        !usedIds.has(existingId.trim())) {
      finalId = existingId.trim();
      console.log(`âœ… Preserving existing ID: ${finalId}`);
    } else {
      // ìƒˆë¡œ ìƒì„±
      let baseId = slugify(text);

      if (usedIds.has(baseId)) {
        let counter = 2;
        while (usedIds.has(`${baseId}-${counter}`)) {
          counter++;
        }
        finalId = `${baseId}-${counter}`;
      } else {
        finalId = baseId;
      }

      if (existingId && !isValidId(existingId)) {
        console.warn(`âš ï¸ Invalid existing ID replaced: "${existingId}" â†’ "${finalId}"`);
      }
    }

    usedIds.add(finalId);
    element.setAttribute('id', finalId);
    headings.push({ level, text, id: finalId });
  });

  return {
    html: document.body.innerHTML,
    headings,
  };
}
```

---

### SHOULD 2. CORS allowedHeaders ì •ë¦¬

**âœ… PATCH: main.ts ìˆ˜ì •**

```typescript
// backend/src/main.ts
app.enableCors({
  origin: process.env.FRONTEND_URL,
  credentials: true,
  methods: ['GET', 'POST', 'PATCH', 'DELETE', 'OPTIONS'],
  allowedHeaders: [
    'Content-Type',
    'Authorization',
    'X-CSRF-Token',  // âœ… CSRF í—¤ë”
    // âŒ ì œê±°: 'X-Internal-Request' (ë” ì´ìƒ ì‚¬ìš© ì•ˆ í•¨)
  ],
});
```

---

### SHOULD 3. CSP connect-src ë¹ˆ ë¬¸ìì—´ ì²˜ë¦¬

**âœ… PATCH: middleware.ts ìˆ˜ì •**

```typescript
// frontend/middleware.ts
export function middleware(request: NextRequest) {
  const nonce = generateNonce();
  const response = NextResponse.next();

  const scriptSources = [
    "'self'",
    `'nonce-${nonce}'`,
  ].join(' ');

  // âœ… PATCH: connect-src ì¡°ê±´ë¶€ ì²˜ë¦¬
  const apiUrl = process.env.NEXT_PUBLIC_API_URL;
  const connectSrc = apiUrl
    ? `'self' ${apiUrl}`
    : "'self'";  // âœ… ë¹ˆ ë¬¸ìì—´ ë°©ì§€

  const cspHeader = `
    default-src 'self';
    script-src ${scriptSources};
    style-src 'self' 'unsafe-inline';
    img-src 'self' data: https:;
    font-src 'self' data:;
    connect-src ${connectSrc};
    frame-ancestors 'none';
    base-uri 'self';
    form-action 'self';
  `.replace(/\s{2,}/g, ' ').trim();

  response.headers.set('Content-Security-Policy', cspHeader);
  response.headers.set('X-Frame-Options', 'DENY');
  response.headers.set('X-Content-Type-Options', 'nosniff');
  response.headers.set('X-Nonce', nonce);

  return response;
}
```

---

### SHOULD 4. hasPgTrgm ìºì‹±

**âœ… PATCH: posts.service.ts ìˆ˜ì •**

```typescript
// backend/src/posts/service/posts.service.ts
import { Injectable, OnModuleInit } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Post } from '../entity/post.entity';

@Injectable()
export class PostsService implements OnModuleInit {
  // âœ… PATCH: ì•± ë¶€íŒ… ì‹œ 1íšŒë§Œ ì²´í¬
  private pgTrgmAvailable: boolean = false;

  constructor(
    @InjectRepository(Post)
    private readonly postRepository: Repository<Post>,
  ) {}

  async onModuleInit() {
    // âœ… ë¶€íŒ… ì‹œ pg_trgm í™•ì¸
    try {
      const result = await this.postRepository.query(
        `SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm'`
      );
      this.pgTrgmAvailable = result.length > 0;
      console.log(`âœ… pg_trgm available: ${this.pgTrgmAvailable}`);
    } catch (error) {
      console.warn('âš ï¸ pg_trgm check failed:', error.message);
      this.pgTrgmAvailable = false;
    }
  }

  async getPosts(
    keyword: string = '',
    tag: string = '',
    page: number = 1,
    pageSize: number = 10
  ): Promise<Post[]> {
    const queryBuilder = this.postRepository
      .createQueryBuilder('post')
      .leftJoinAndSelect('post.tags', 'tag')
      .where('post.status = :status', { status: 'published' });

    if (keyword && keyword.trim().length >= 2) {
      const cleanKeyword = keyword.trim();

      // âœ… PATCH: ìºì‹œëœ ê°’ ì‚¬ìš©
      if (this.pgTrgmAvailable) {
        // pg_trgm ê²€ìƒ‰
        queryBuilder.andWhere(
          '(post.plainText % :keyword OR post.title % :keyword)',
          { keyword: cleanKeyword }
        );
        queryBuilder.addSelect(
          `(similarity(post.title, :keyword) * 2 + similarity(post.plainText, :keyword))`,
          'relevance'
        );
        queryBuilder.setParameter('keyword', cleanKeyword);
        queryBuilder.orderBy('relevance', 'DESC');
      } else {
        // Fallback: ILIKE
        queryBuilder.andWhere(
          '(post.title ILIKE :keywordPattern OR post.plainText ILIKE :keywordPattern)',
          { keywordPattern: `%${cleanKeyword}%` }
        );
        queryBuilder.orderBy('post.publishDate', 'DESC');
      }
    } else if (!keyword) {
      queryBuilder.orderBy('post.publishDate', 'DESC');
    }

    if (tag) {
      queryBuilder.andWhere('tag.name = :tag', { tag });
    }

    queryBuilder
      .skip((page - 1) * pageSize)
      .take(pageSize);

    return queryBuilder.getMany();
  }

  // ... ë‚˜ë¨¸ì§€ ë©”ì„œë“œë„ this.pgTrgmAvailable ì‚¬ìš©
}
```

---

### SHOULD 5. Heading processor ë¶ˆí•„ìš” import ì œê±°

ìœ„ SHOULD 1ì— ì´ë¯¸ í¬í•¨:
```typescript
// âŒ ì œê±°
// import crypto from 'crypto';
```

---

## âœ… PATCH ì ìš© ì²´í¬ë¦¬ìŠ¤íŠ¸

### MUST (ì¦‰ì‹œ ì ìš©)

- [ ] **CSRF ë‚´ë¶€ ìš°íšŒ ì œê±°**
  - [ ] `CsrfGuard`ì—ì„œ `X-Internal-Request` ë°”ì´íŒ¨ìŠ¤ ì œê±°
  - [ ] SSRì—ì„œ CSRF í† í° ì‚¬ìš©í•˜ë„ë¡ ìˆ˜ì •
  - [ ] Server Actions CSRF í† í° ì ìš©
  - [ ] í™˜ê²½ë³€ìˆ˜ `INTERNAL_REQUEST_SECRET` ì œê±°

- [ ] **logout clearCookie ì˜µì…˜**
  - [ ] `domain`, `path` ì˜µì…˜ ì¶”ê°€
  - [ ] loginê³¼ ë™ì¼í•œ ì˜µì…˜ ì‚¬ìš© í™•ì¸

- [ ] **data:image SVG ì°¨ë‹¨**
  - [ ] DOMPurify Hook PNG/JPG/GIF/WebPë§Œ í—ˆìš©
  - [ ] `ALLOWED_URI_REGEXP`ì—ì„œ `data:image` ì œê±°
  - [ ] SVG ê³µê²© í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ì¶”ê°€

### SHOULD (ê¶Œì¥)

- [ ] ê¸°ì¡´ ID ìœ íš¨ì„± ê²€ì¦ (`isValidId`)
- [ ] CORS allowedHeaders ì •ë¦¬
- [ ] CSP connect-src ë¹ˆ ë¬¸ìì—´ ì²˜ë¦¬
- [ ] `hasPgTrgm` ìºì‹± (OnModuleInit)
- [ ] ë¶ˆí•„ìš” import ì œê±°

---

## ğŸ“Š ë³€ê²½ ì‚¬í•­ ìš”ì•½

| í•­ëª© | v3.1 FINAL | PATCH |
|------|-----------|-------|
| **CSRF ë‚´ë¶€ ìš°íšŒ** | X-Internal-Request ë°”ì´íŒ¨ìŠ¤ | âœ… ì œê±°, SSRë„ í† í° ì‚¬ìš© |
| **logout ì¿ í‚¤** | clearCookie() ì˜µì…˜ ì—†ìŒ | âœ… domain/path ì¶”ê°€ |
| **data:image** | SVG í¬í•¨ ì „ì²´ í—ˆìš© | âœ… PNG/JPG/GIF/WebPë§Œ |
| **ê¸°ì¡´ ID** | ë¬´ì¡°ê±´ ë³´ì¡´ | âœ… ìœ íš¨ì„± ê²€ì¦ ì¶”ê°€ |
| **hasPgTrgm** | ìš”ì²­ë§ˆë‹¤ DB ì¡°íšŒ | âœ… ë¶€íŒ… ì‹œ ìºì‹± |

---

**íŒ¨ì¹˜ ë²„ì „**: 3.1 FINAL PATCH
**ì‘ì„±ì¼**: 2025-12-30
**ìš°ì„ ìˆœìœ„**: MUST 3ê°œëŠ” ë°°í¬ ì „ í•„ìˆ˜ ì ìš©